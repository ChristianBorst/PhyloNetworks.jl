{
    "docs": [
        {
            "location": "/", 
            "text": "PhyloNetworks\n\n\nPhyloNetworks is a Julia package for the manipulation, visualization and inference of phylogenetic networks.  SNaQ implements the statistical inference method in \nSol\ns-Lemus and An\n 2016\n. The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.\n\n\n\n\nPhyloNetworks.jl Documentation\n\n\n\n\nPhyloNetworks\n\n\nPhyloNetworks.jl Documentation\n\n\nFunctions\n\n\nIndex\n\n\n\n\n\n\nInserting data into the TICR pipeline at various stages\n\n\nTo run MrBayes: You already have alignments\n\n\nTo run BUCKy: You already have MrBayes output\n\n\n\n\n\n\nSimple use of Julia types\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nPhyloNetworks.HybridNetwork\n \n \nType\n.\n\n\nHybridNetwork type\n Explicit network or tree with the following attributes:\n\n\n\n\nnumTaxa\n\n\nnumNodes (total number of nodes)\n\n\nnumEdges\n\n\nnumHybrids (number of hybrid nodes)\n\n\nedge (array of Edges)\n\n\nnode (array of Nodes)\n\n\nroot (index of root in vector 'node'. May be artificial, for printing and traversal purposes only.)\n\n\nhybrid (array of Nodes: those are are hybrid nodes)\n\n\nleaf (array of Nodes: those that are leaves)\n\n\nloglik (negative log pseudolik after estimation)\n\n\nisRooted (true or false)\n\n\n\n\n#\n\n\nPhyloNetworks.DataCF\n \n \nType\n.\n\n\nDataCF type\n\n\ntype that contains the following attributes:\n\n\n\n\nquartet (vector of Quartets)\n\n\nnumQuartets\n\n\ntree (vector of trees: empty if a table of CF was input instead of list of trees)\n\n\nnumTrees (-1 if a table CF was input instead of list of trees)\n\n\nrepSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)\n\n\n\n\nThe list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.\n\n\n#\n\n\nPhyloNetworks.Quartet\n \n \nType\n.\n\n\nQuartet type\n\n\ntype that saves the information on a given 4-taxon subset. It contains the following attributes:\n\n\n\n\nnumber\n\n\ntaxon (vector of taxon names)\n\n\nobsCF (vector of observed CF)\n\n\nlogPseudoLik\n\n\nngenes (number of gene trees used to compute the observed CF: -1 if unknown)\n\n\nqnet (internal topological structure that saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data)\n\n\n\n\n#\n\n\nPhyloNetworks.readTopology\n \n \nFunction\n.\n\n\nreadTopology(file name); readTopology(parenthetical description)\n\n\nfunction to read tree or network topology from parenthetical format. Input: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.\n\n\n#\n\n\nPhyloNetworks.readTopologyLevel1\n \n \nFunction\n.\n\n\nreadTopologyLevel1(filename); readTopologyLevel1(parenthetical format)\n\n\nsame as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.\n\n\n#\n\n\nPhyloNetworks.tipLabels\n \n \nFunction\n.\n\n\ntipLabels(net::HybridNetwork)\n\n\nreturns a vector of taxon names (at the leaves) from a HybridNetwork object\n\n\n#\n\n\nPhyloNetworks.writeTopology\n \n \nFunction\n.\n\n\nwriteTopology(net)\nwriteTopology(net, filename)\n\n\n\n\nwrite the parenthetical format of a HybridNetwork object, as a string or to a file. Optional arguments (default values):\n\n\n\n\ndi (false): write in format for Dendroscope\n\n\nround (false): rounds branch lengths and heritabilities \u03b3\n\n\ndigits (3): digits after the decimal place for rounding\n\n\n\n\nIf the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.\n\n\n#\n\n\nPhyloNetworks.deleteleaf!\n \n \nFunction\n.\n\n\ndeleteleaf!(HybridNetwork,Int64; index=false, simplify=true)\n \ndeleteleaf!(HybridNetwork,leafName::AbstractString; simplify=true)\n \ndeleteleaf!(HybridNetwork,Node; simplify=true)\n\n\nDeletes a leaf node from the network, possibly from its name, number, or index in the network's array of nodes.\n\n\nsimplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.\n\n\nThe first version does \nnot\n require that \nnode\n is a leaf, so might be used to remove nodes of degree 2. The other versions do, and use the default simplify=true.\n\n\nWarning: does \nnot\n update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.\n\n\n#\n\n\nPhyloNetworks.printEdges\n \n \nFunction\n.\n\n\nprintEdges(net::HybridNetwork)\n\n\nprints the information on the edges of net: edge number, node numbers of nodes attached to it, in which cycle it is contained (-1 if no cycle), can it contain root, is it an identifiable edge, length, is it hybrid, gamma value\n\n\n#\n\n\nPhyloNetworks.printNodes\n \n \nFunction\n.\n\n\nprintNodes(net::HybridNetwork)\n\n\nprints information on the nodes of net: node number, in which cycle it is contained (-1 if no cycle), is it hybrid, does it has hybrid edges, edges number attached to it\n\n\n#\n\n\nPhyloNetworks.readTrees2CF\n \n \nFunction\n.\n\n\nreadTrees2CF(treefile)\nreadTrees2CF(vector of trees)\n\n\n\n\nRead trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:\n\n\n\n\nquartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.\n\n\nwhichQ=\"rand\": to choose a random sample of 4-taxon subsets\n\n\nnumQ: size of random sample (ignored if whichQ is not set to \"rand\")\n\n\nwriteTab=false: does not write the observedCF to a table (default true)\n\n\nCFfile: name of file to save the observedCF (default tableCF.txt)\n\n\nwriteQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).\n\n\n\n\n#\n\n\nPhyloNetworks.readTableCF\n \n \nFunction\n.\n\n\nreadTableCF(file)\nreadTableCF(data frame)\n\n\n\n\nRead a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named 'CF12_34', 'CF13_24' and 'CF14_23', or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.\n\n\nOptional arguments:\n\n\n\n\nsummaryfile: if specified, a summary file will be created with that name.\n\n\nsep (for the second form only): to specify the type of separator in the file, with single quotes: sep=';'.\n\n\n\n\n#\n\n\nPhyloNetworks.readInputTrees\n \n \nFunction\n.\n\n\nreadInputTrees(file)\n\n\nfunction to read a text file with a list of trees in parenthetical format (one tree per line), it returns an array of HybridNetwork object.\n\n\n#\n\n\nPhyloNetworks.summarizeDataCF\n \n \nFunction\n.\n\n\nsummarizeDataCF(d::DataCF)\n\n\nfunction to summarize the information contained in a DataCF object. It has the following optional arguments: - filename: if provided, the summary will be saved in the filename, not to screen - pc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold\n\n\n#\n\n\nPhyloNetworks.snaq!\n \n \nFunction\n.\n\n\nsnaq!(T::HybridNetwork, d::DataCF)\n\n\nEstimate the network (or tree) to fit observed concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. The search starts from topology \nT\n, which can be a tree or a network with no more than \nhmax\n hybrid nodes. The function name ends with ! because it modifies the CF data \nd\n by updating its attributes \nexpCF\n: CFs expected under the network model. It does \nnot\n modify \nT\n. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\n\nThere are many optional arguments, including\n\n\n\n\nhmax: maximum number of hybridizations allowed (default 1)\n\n\nverbose: if true, it prints information about the numerical optimization\n\n\nruns: number of independent starting points for the search (default 10)\n\n\noutgroup: outgroup taxon to root the estimated topology at the very end\n\n\nfilename: root name for the output files. Default is \"snaq\". If empty (\"\"),   files are \nnot\n created, progress log goes to the screen only (standard out)   and the best network is returned.\n\n\nseed: seed to replicate a given search\n\n\n\n\nSee also: \ntopologyMaxQPseudolik!\n to optimize parameters on a fixed topology, and \ntopologyQPseudolik!\n to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.\n\n\nReference: Claudia Sol\u00eds-Lemus and C\u00e9cile An\u00e9 (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. \nPLoS Genetics\n 12(3):e1005896\n\n\n#\n\n\nPhyloNetworks.readSnaqNetwork\n \n \nFunction\n.\n\n\nreadSnaqNetwork(output file)\n\n\nfunction to read the estimated network from an .out file generated by the snaq function\n\n\n#\n\n\nPhyloNetworks.snaqDebug\n \n \nFunction\n.\n\n\nsnaqDebug(currT::HybridNetwork,d::DataCF)\n\n\nfunction to replicate a given run that produces error according to the .err file generated by snaq. The same settings used in that run should be used in this function, specially the seed. See the readme file online for more details.\n\n\n#\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n \n \nFunction\n.\n\n\ntopologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)\n\n\nEstimate the branch lengths and inheritance probabilities (\u03b3's) for a given network topology. The network is \nnot\n modified, only the object \nd\n is, with updated expected concordance factors.\n\n\nOuput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with \nnet.loglik\n.\n\n\nOptional arguments (default value):\n\n\n\n\nverbose (false): if true, information on the numerical optimization is printed to screen\n\n\nftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4):   absolute and relative tolerance values for the pseudo-deviance function   and the parameters\n\n\n\n\n#\n\n\nPhyloNetworks.topologyQPseudolik!\n \n \nFunction\n.\n\n\ntopologyQPseudolik!(net::HybridNetwork, d::DataCF)\n\n\nCalculate the quartet pseudo-deviance of a given network/tree for DataCF \nd\n. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\n\nBe careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.\n\n\nThe loglik attribute of the network is undated, and \nd\n is updated with the expected concordance factors under the input network.\n\n\n#\n\n\nPhyloNetworks.rootatnode!\n \n \nFunction\n.\n\n\nrootatnode!(HybridNetwork, nodeNumber::Int64; index=false::Bool)\n\n\nrootatnode!(HybridNetwork, Node)\n\n\nrootatnode!(HybridNetwork, nodeName::AbstractString)\n\n\nRoots the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes isChild1 and containRoot are updated along the way. Use \nplot(net, showNodeNumber=true, showEdgeLength=false)\n to visualize and identify a node of interest.\n\n\nReturns the network.\n\n\nWarnings: - If the node is a leaf, the root will be placed along   the edge adjacent to the leaf, with a message. This might add a new node. - If the desired root placement is incompatible with one or more hybrids, then   * a RootMismatch error is thrown   * the input network will still have some attributes modified.\n\n\nSee also: \nrootonedge!\n.\n\n\n#\n\n\nPhyloNetworks.rootonedge!\n \n \nFunction\n.\n\n\nrootonedge!(HybridNetwork, edgeNumber::Int64; index=false::Bool)\n\n\nrootonedge!(HybridNetwork, Edge)\n\n\nRoots the network/tree object along an edge with number 'edgeNumber' (by default) or with index 'edgeNumber if index=true. Attributes isChild1 and containRoot are updated along the way.\n\n\nThis adds a new node and a new edge to the network. Use \nplot(net, showEdgeNumber=true, showEdgeLength=false)\n to visualize and identify an edge of interest.\n\n\nSee also: \nrootatnode!\n.\n\n\n#\n\n\nPhyloNetworks.directEdges!\n \n \nFunction\n.\n\n\ndirectEdges!(net::HybridNetwork; checkMajor=true::Bool)\n\n\nUpdates the edges' attribute \nisChild1\n, according to the root placement. Also updates edges' attribute \ncontainRoot\n, for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.\n\n\nWarning: Assumes that isChild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).\n\n\nReturns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.\n\n\n#\n\n\nPhyloNetworks.preorder!\n \n \nFunction\n.\n\n\npreorder!(net::HybridNetwork)\n\n\nUpdates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directEdges!\n\n\n#\n\n\nPhyloNetworks.cladewiseorder!\n \n \nFunction\n.\n\n\ncladewiseorder!(net::HybridNetwork)\n\n\nUpdates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling cladewiseorder!, using directEdges!\n\n\n#\n\n\nPhyloNetworks.fittedQuartetCF\n \n \nFunction\n.\n\n\nfittedQuartetCF(d::DataCF, format::Symbol)\n\n\nreturn a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.\n\n\n\n\nif wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns   for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.\n\n\nif long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns:   4 columns for the taxon names, one column to give the quartet resolution, one column for   the observed CF and the last column for the expected CF.\n\n\n\n\nsee also: \ntopologyQPseudolik!\n and \ntopologyMaxQPseudolik!\n to update the fitted CF expected under a specific network, inside the DataCF object \nd\n.\n\n\n#\n\n\nPhyloNetworks.plotNetGraphViz\n \n \nFunction\n.\n\n\nplotNetGraphViz(net::HybridNetwork)\n\n\nfunction to plot a HybridNetwork object. The plot will be saved in the working directory as a svg file. We are working on allowing other file formats, and to have the plot pop out in a window. This function has the following optional arguments: - imageName: name for plot file (default netImage) - mainTree: if true, only the underlying tree (with major hybrid edges) is plotted (default false) - width: width of image in inches (default 6) - height: height of image in inches (default 8) - vert: if true, plot displayed from top to bottom (default tre) - internalLabels: if true, prints number for internal nodes (default false) - fontSize: font size for taxon names (default 16.0) - hybridColor: color for hybrid edges (default green4) - unrooted: if true, prints the topology unrooted - nodeSeparation: minimum distance between nodes in inches (default 0.8) - labelAngle: angle for leaf label placement (default 180.0) - labelDistance: distance for leaf label placement (default 3.0) - includeGamma: if true, includes the gamma values in the plot (default false) - includeLength: if true, includes the branch lengths in the plot (default false\n\n\n#\n\n\nGadfly.plot\n \n \nFunction\n.\n\n\nplot(net::HybridNetwork; useEdgeLength=false, mainTree=false, showTipLabel=true,\n     showNodeNumber=false, showEdgeLength=false, showGamma=false, edgeColor=colorant\nblack\n,\n     majorHybridEdgeColor=colorant\ndeepskyblue4\n, minorHybridEdgeColor=colorant\ndeepskyblue\n,\n     showEdgeNumber=false, showIntNodeLabel=false, edgeLabel=[], nodeLabel=[])\n\n\n\n\nPlots a network, from left to right.\n\n\n\n\nuseEdgeLength: if true, the tree edges and major hybrid edges are   drawn proportionally to their length. Minor hybrid edges are not, however.   Note that edge lengths in coalescent units may scale very poorly with time.\n\n\nmainTree: if true, the minor hybrid edges are ommitted.\n\n\nshowTipLabel: if true, taxon labels are shown. You may need to zoom out to see them.\n\n\nshowNodeNumbers: if true, nodes are labelled with the number used internally.\n\n\nshowEdgeLength: if true, edges are labelled with their length (above)\n\n\nshowGamma: if true, hybrid edges are labelled with their heritability (below)\n\n\nedgeColor: color for tree edges. black by default.\n\n\nmajorHybridEdgeColor: color for major hybrid edges\n\n\nminorHybridEdgeColor: color for minor hybrid edges\n\n\nshowEdgeNumber: if true, edges are labelled with the number used internally.\n\n\nshowIntNodeLabel: if true, internal nodes are labelled with their names.   Useful for hybrid nodes, which do have tags like '#H1'.\n\n\nedgeLabel: dataframe with two columns: the first with edge numbers, the second with labels   (like bootstrap values) to annotate edges. empty by default.\n\n\nnodeLabel: dataframe with two columns: the first with node numbers, the second with labels   (like bootstrap values for hybrid relationships) to annotate nodes. empty by default.\n\n\n\n\nNote that plot() actually modifies some (minor) attributes of the network, as it calls directEdges!, preorder! and cladewiseorder!.\n\n\nIf hybrid edges cross tree and major edges, you may choose to rotate some tree edges to eliminate crossing edges, using rotate!.\n\n\n#\n\n\nPhyloNetworks.setLength!\n \n \nFunction\n.\n\n\nsetLength!(Edge,new length)\n\n\nset a new length for an object Edge. The new length needs to be positive. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their lengths. You can then change the length of the 3rd edge with setLength!(net.edge[3],1.2).\n\n\n#\n\n\nPhyloNetworks.setGamma!\n \n \nFunction\n.\n\n\nsetGamma!(Edge,new gamma)\n\n\nsets a gamma value for a hybrid edge (it has to be a hybrid edge) and new gamma needs to be (0,1). The function will automatically change the gamma value for the other hybrid edge to 1-gamma. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their gammas. You can then change the length of the hybrid edge (assume it is in position 3) with setGamma!(net.edge[3],0.2). This will automatically set the gamma for the other hybrid edge to 0.8.\n\n\n#\n\n\nPhyloNetworks.mapAllelesCFtable\n \n \nFunction\n.\n\n\nmapAllelesCFtable(mapping file, cf file)\n\n\nfunction that change the allele names in the CF table to species names. The new DataFrame object is returned. Optional argument: filename for the resulting CF table. If not specified, then no CF is saved as file.\n\n\n#\n\n\nPhyloNetworks.deleteHybridThreshold!\n \n \nFunction\n.\n\n\ndeleteHybridThreshold!(net::HybridNetwork,gamma::Float64)\n\n\nDeletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.\n\n\n\n\nif gamma\n0.5: deletes     minor hybrid edges with gamma value \n  threshold\n\n\nif gamma=0.5: deletes all minor hybrid edges (i.e gamma value \n= threshold)\n\n\n\n\nWarning: assumes correct isMajor attributes.\n\n\n#\n\n\nPhyloNetworks.displayedTrees\n \n \nFunction\n.\n\n\ndisplayedTrees(net::HybridNetwork, gamma::Float64)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nExtracts all trees displayed in a network, following hybrid edges with heritability \n= gamma threshold (or \n0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than gamma. Returns an array of trees, as HybridNetwork objects.\n\n\n#\n\n\nPhyloNetworks.majorTree\n \n \nFunction\n.\n\n\nmajorTree(net::HybridNetwork)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nExtracts the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node. Returns a HybridNetwork object.\n\n\n#\n\n\nPhyloNetworks.minorTreeAt\n \n \nFunction\n.\n\n\nminorTreeAt(net::HybridNetwork, hybindex::Int64)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nExtracts the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=hybindex), where the minor hybrid edge is kept instead of the major hybrid edge.\n\n\n#\n\n\nPhyloNetworks.displayedNetworkAt!\n \n \nFunction\n.\n\n\ndisplayedNetworkAt!(net::HybridNetwork, node::Node)\n\n\nWarning: assumes correct isMajor attributes.\n\n\nDeletes all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before.\n\n\n#\n\n\nPhyloNetworks.hardwiredClusters\n \n \nFunction\n.\n\n\nhardwiredClusters(net::HybridNetwork, S::Union{Vector{ASCIIString},Vector{Int64}})\n\n\nReturns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.\n\n\nEach row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).\n\n\n\n\nfirst column: edge number\n\n\nnext columns: 0/1 values. 1=descendant of edge, 0=not a descendant, or missing taxon.\n\n\nlast column:  10/11 values. 10=tree edge, 11=hybrid edge\n\n\n\n\n#\n\n\nPhyloNetworks.hardwiredCluster\n \n \nFunction\n.\n\n\nhardwiredCluster(edge::Edge,taxa::Union{Vector{ASCIIString},Vector{Int64}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{ASCIIString},Vector{Int64}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{ASCIIString},Vector{Int64}},\n                  visited::Vector{Int64})\n\n\n\n\nCalculate the hardwired cluster of \nnode\n, coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).\n\n\nThe node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.\n\n\nvisited: vector of node numbers, of all visited nodes.\n\n\nExamples: #\"\n\n\njulia\n net5 = \n(A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));\n |\n readTopology |\n directEdges! ;\n\njulia\n taxa = net5 |\n tipLabels # ABC EF D\n6-element Array{ASCIIString,1}:\n \nA\n\n \nB\n\n \nC\n\n \nE\n\n \nF\n\n \nD\n\n\njulia\n hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Array{Bool,1}:\n false\n false\n  true\n  true\n  true\n false\n\n\n\n\n#\n\n\nPhyloNetworks.hardwiredClusterDistance\n \n \nFunction\n.\n\n\nhardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)\n\n\nTakes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.\n\n\nIf the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.\n\n\n#\n\n\nPhyloNetworks.treeEdgesBootstrap\n \n \nFunction\n.\n\n\ntreeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)\n\n\nread a list of bootstrap networks (\nboot_net\n) and a reference network (\nref_net\n), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (\u03b3\n0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.\n\n\noutput: - a data frame with one row per tree edge and two columns: edge number, bootstrap support   (as a percentage) - the major tree from the reference network, where minor hybrid edges (with \u03b3\n0.5)   have been removed.\n\n\n#\n\n\nPhyloNetworks.hybridDetection\n \n \nFunction\n.\n\n\nhybridDetection(net::Vector{HybridNetwork}, net1::HybridNetwork, outgroup::AbstractString)\n\n\nfunction can only compare hybrid nodes in networks that have the same underlying major tree also, need to root all networks in the same place, and the root has to be compatible with the direction of the hybrid edges\n\n\nit computes the rooted hardwired distance between networks, the root matters. input: vector of bootstrap networks (net), estimated network (net1), outgroup\n\n\nreturns\n\n\n\n\n\n\na matrix with one row per bootstrap network, and 2*number of hybrids in net1, column i corresponds to whether hybrid i (net1.hybrid[i]) is found in the bootstrap network, column 2i+1 corresponds to the estimated gamma on the bootstrap network (0.0 if hybrid not found)\n\n\n\n\n\n\nlist of discrepant trees (trees not matching the main tree in net1)\n\n\n\n\n\n\n#\n\n\nPhyloNetworks.summarizeHFdf\n \n \nFunction\n.\n\n\nsummarizeHFdf(HFmat::Matrix)\n\n\nfunction to summarize df output from hybridDetection input: HFdf (see hybridDetection) returns dataframe with one row per hybrid, and 5 columns:\n\n\n\n\n\n\nhybrid index (order from estimated network, see hybridDetection),\n\n\n\n\n\n\nnumber of bootstrap trees that match the underlying tree of estimated network, - number of bootstrap networks that have the hybrid\n\n\n\n\n\n\nmean estimated gamma in the bootstrap networks that have the hybrid\n\n\n\n\n\n\nsd estimated gamma in the bootstrap networks that have the hybrid also\n\n\n\n\n\n\nlast row has index -1, and the third column has the number of networks that have all hybrids (hybrid index, mean gamma, sd gamma are meaningless in this last row)\n\n\n#\n\n\nPhyloNetworks.hybridBootstrapSupport\n \n \nFunction\n.\n\n\nhybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)\n\n\nMatch hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If \nrooted=true\n, all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).\n\n\nTwo hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with \u03b3\n0.5) and one is its minor sister (following the major hybrid edge with \u03b3\n0.5).\n\n\nTo calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If \nrooted=false\n, sister clades are considered as bipartitions.\n\n\nOutput:\n\n\n\n\n\n\na \"node\" data frame with one row per clade and 9 columns giving:\n\n\n\n\n\n\nclade\n: the clade's name, like the taxon name (if a hybrid is a single taxon) or      the hybrid tag (like 'H1') in the reference network\n\n\n\n\nnode\n: the node number in the reference network. NA if the clade is not in this network.\n\n\nhybridnode\n: typically the same node number as above, except for hybrid clades in the      reference network. For those, the hybrid node number is listed here.\n\n\nedge\n: number of the parent edge, parent to the node in column 2,      if found in the ref network. NA otherwise.\n\n\nBS_hybrid\n: percentage of bootstrap networks in which the clade is found to be a hybrid clade.\n\n\nBS_sister\n: percentage of bootstrap networks in which the clade is found to be sister to      some hybrid clade (sum of the next 2 columns)\n\n\nBS_major_sister\n: percentage of bootstrap networks in which the clade is found to be the      major sister to some hybrid clade\n\n\nBS_minor_sister\n: same as 7, but minor\n\n\n\n\nBS_hybrid_samesisters\n: percentage of bootstrap networks in which the clade is found to be      a hybrid and with the same set of sister clades as in the reference network.      Applies to hybrid clades found in the reference network only, NA for all other clades.\n\n\n\n\n\n\nan \"edge\" data frame with one row for each pair of clades, and 8 columns:\n\n\n\n\n\n\nedge\n: hybrid edge number, if the edge appears in the reference network. NA otherwise.\n\n\n\n\nhybrid_clade\n: name of the clade found to be a hybrid, descendent of 'edge'\n\n\nhybrid\n: node number of that clade, if it appears in the reference network. NA otherwise.\n\n\nsister_clade\n: name of the clade that is sister to 'edge', i.e. be sister to a hybrid\n\n\nsister\n: node number of that clade, if in the ref network.\n\n\nBS_hybrid_edge\n: percentage of bootstrap networks in which 'edge' is found to be a hybrid      edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in      the 'sister' column is one of its sisters.\n\n\nBS_major\n: percentage of bootstrap networks in which 'edge' is found to be a major hybrid      edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its      major sister.\n\n\n\n\nBS_minor\n: same as 7, but minor\n\n\n\n\n\n\na \"clade\" data frame to describe the make up of all clades found as hybrids or sisters,   starting with a column \ntaxa\n that lists all taxa. All other columns correspond to a given   clade and contain true/false values. \ntrue\n means that a given taxon belongs in a given clade.   For a clade named \nH1\n, for instance, and if the data frame was named 'cla', the   list of taxa in this clade can be obtained with \ncla[:taxa][cla[:H1]]\n.\n\n\n\n\n\n\nan array of gamma values, with one row for each bootstrap network and two columns (major/minor) for each hybrid   edge in the reference network. If this hybrid edge was found in the bootstrap network   (i.e. same hybrid and sister clades, after removal of all other hybrid nodes),   its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.\n\n\n\n\n\n\nan vector with the number of each hybrid edge in the reference network, in the same order   as for the columns in the array of gamma values above.\n\n\n\n\n\n\n#\n\n\nPhyloNetworks.bootsnaq\n \n \nFunction\n.\n\n\nbootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)\n\n\n\n\nBootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame \ndf\n. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see \nreadBootstrapTrees\n to generate this, from a file containing a list of bootstrap files: one per locus).\n\n\nFrom each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology \nT\n. Optional arguments include the following, with default values in parentheses:\n\n\n\n\nhmax (1): max number of reticulations in the estimated networks\n\n\nnrep (10): number of bootstrap replicates.\n\n\nruns (10): number of independent optimization runs for each replicate\n\n\nfilename (bootsnaq): root name for output files\n\n\nseed (0 to get a random seed from the clock): seed for random number generator\n\n\n\n\n#\n\n\nPhyloNetworks.readBootstrapTrees\n \n \nFunction\n.\n\n\nreadBootstrapTrees(filename)\n\n\n\n\ninput: name of file containing the path/name to multiple bootstrap files, one per line. Each bootstrap file corresponds to bootstrap trees from a single gene.\n\n\noutput: vector of vectors of trees.\n\n\n#\n\n\nPhyloNetworks.readMultiTopology\n \n \nFunction\n.\n\n\nreadMultiTopology(file)\n\n\nRead a text file with a list of networks in parenthetical format (one per line). Crash if a network is broken over several lines. Return an array of HybridNetwork object.\n\n\n#\n\n\nPhyloNetworks.hybridatnode!\n \n \nFunction\n.\n\n\nhybridatnode!(net::HybridNetwork, nodeNumber::Int64)\n\n\nChanges the hybrid in a cycle to the node with number \nnodeNumber\n. This node must be in one (and only one) cycle, otherwise an error will be thrown.\n\n\nExample #\"\n\n\njulia\n net = readTopology(\n(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\n);\njulia\n plot(net, showNodeNumber=true)\njulia\n hybridatnode!(net, -4)\njulia\n plot(net)\n\n\n\n\n\n\nIndex\n\n\n\n\nPhyloNetworks.DataCF\n\n\nPhyloNetworks.HybridNetwork\n\n\nPhyloNetworks.Quartet\n\n\nGadfly.plot\n\n\nPhyloNetworks.bootsnaq\n\n\nPhyloNetworks.cladewiseorder!\n\n\nPhyloNetworks.deleteHybridThreshold!\n\n\nPhyloNetworks.deleteleaf!\n\n\nPhyloNetworks.directEdges!\n\n\nPhyloNetworks.displayedNetworkAt!\n\n\nPhyloNetworks.displayedTrees\n\n\nPhyloNetworks.fittedQuartetCF\n\n\nPhyloNetworks.hardwiredCluster\n\n\nPhyloNetworks.hardwiredClusterDistance\n\n\nPhyloNetworks.hardwiredClusters\n\n\nPhyloNetworks.hybridBootstrapSupport\n\n\nPhyloNetworks.hybridDetection\n\n\nPhyloNetworks.hybridatnode!\n\n\nPhyloNetworks.majorTree\n\n\nPhyloNetworks.mapAllelesCFtable\n\n\nPhyloNetworks.minorTreeAt\n\n\nPhyloNetworks.plotNetGraphViz\n\n\nPhyloNetworks.preorder!\n\n\nPhyloNetworks.printEdges\n\n\nPhyloNetworks.printNodes\n\n\nPhyloNetworks.readBootstrapTrees\n\n\nPhyloNetworks.readInputTrees\n\n\nPhyloNetworks.readMultiTopology\n\n\nPhyloNetworks.readSnaqNetwork\n\n\nPhyloNetworks.readTableCF\n\n\nPhyloNetworks.readTopology\n\n\nPhyloNetworks.readTopologyLevel1\n\n\nPhyloNetworks.readTrees2CF\n\n\nPhyloNetworks.rootatnode!\n\n\nPhyloNetworks.rootonedge!\n\n\nPhyloNetworks.setGamma!\n\n\nPhyloNetworks.setLength!\n\n\nPhyloNetworks.snaq!\n\n\nPhyloNetworks.snaqDebug\n\n\nPhyloNetworks.summarizeDataCF\n\n\nPhyloNetworks.summarizeHFdf\n\n\nPhyloNetworks.tipLabels\n\n\nPhyloNetworks.topologyMaxQPseudolik!\n\n\nPhyloNetworks.topologyQPseudolik!\n\n\nPhyloNetworks.treeEdgesBootstrap\n\n\nPhyloNetworks.writeTopology", 
            "title": "Home"
        }, 
        {
            "location": "/#phylonetworks", 
            "text": "PhyloNetworks is a Julia package for the manipulation, visualization and inference of phylogenetic networks.  SNaQ implements the statistical inference method in  Sol s-Lemus and An  2016 . The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.", 
            "title": "PhyloNetworks"
        }, 
        {
            "location": "/#phylonetworksjl-documentation", 
            "text": "PhyloNetworks  PhyloNetworks.jl Documentation  Functions  Index    Inserting data into the TICR pipeline at various stages  To run MrBayes: You already have alignments  To run BUCKy: You already have MrBayes output    Simple use of Julia types", 
            "title": "PhyloNetworks.jl Documentation"
        }, 
        {
            "location": "/#functions", 
            "text": "#  PhyloNetworks.HybridNetwork     Type .  HybridNetwork type  Explicit network or tree with the following attributes:   numTaxa  numNodes (total number of nodes)  numEdges  numHybrids (number of hybrid nodes)  edge (array of Edges)  node (array of Nodes)  root (index of root in vector 'node'. May be artificial, for printing and traversal purposes only.)  hybrid (array of Nodes: those are are hybrid nodes)  leaf (array of Nodes: those that are leaves)  loglik (negative log pseudolik after estimation)  isRooted (true or false)   #  PhyloNetworks.DataCF     Type .  DataCF type  type that contains the following attributes:   quartet (vector of Quartets)  numQuartets  tree (vector of trees: empty if a table of CF was input instead of list of trees)  numTrees (-1 if a table CF was input instead of list of trees)  repSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)   The list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.  #  PhyloNetworks.Quartet     Type .  Quartet type  type that saves the information on a given 4-taxon subset. It contains the following attributes:   number  taxon (vector of taxon names)  obsCF (vector of observed CF)  logPseudoLik  ngenes (number of gene trees used to compute the observed CF: -1 if unknown)  qnet (internal topological structure that saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data)   #  PhyloNetworks.readTopology     Function .  readTopology(file name); readTopology(parenthetical description)  function to read tree or network topology from parenthetical format. Input: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be interpreted as the parenthetical description.  #  PhyloNetworks.readTopologyLevel1     Function .  readTopologyLevel1(filename); readTopologyLevel1(parenthetical format)  same as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.  #  PhyloNetworks.tipLabels     Function .  tipLabels(net::HybridNetwork)  returns a vector of taxon names (at the leaves) from a HybridNetwork object  #  PhyloNetworks.writeTopology     Function .  writeTopology(net)\nwriteTopology(net, filename)  write the parenthetical format of a HybridNetwork object, as a string or to a file. Optional arguments (default values):   di (false): write in format for Dendroscope  round (false): rounds branch lengths and heritabilities \u03b3  digits (3): digits after the decimal place for rounding   If the current root placement is not admissible, other placements are tried. The network is updated with this new root placement, if successful.  #  PhyloNetworks.deleteleaf!     Function .  deleteleaf!(HybridNetwork,Int64; index=false, simplify=true)   deleteleaf!(HybridNetwork,leafName::AbstractString; simplify=true)   deleteleaf!(HybridNetwork,Node; simplify=true)  Deletes a leaf node from the network, possibly from its name, number, or index in the network's array of nodes.  simplify: if true and if deleting the node results in 2 hybrid edges forming a cycle of k=2 nodes, then these hybrid edges are merged and simplified as a single tree edge.  The first version does  not  require that  node  is a leaf, so might be used to remove nodes of degree 2. The other versions do, and use the default simplify=true.  Warning: does  not  update attributes related to level-1 networks, such as inCycle, partition, gammaz, etc. Does not require branch lengths, and designed to work on networks of all levels.  #  PhyloNetworks.printEdges     Function .  printEdges(net::HybridNetwork)  prints the information on the edges of net: edge number, node numbers of nodes attached to it, in which cycle it is contained (-1 if no cycle), can it contain root, is it an identifiable edge, length, is it hybrid, gamma value  #  PhyloNetworks.printNodes     Function .  printNodes(net::HybridNetwork)  prints information on the nodes of net: node number, in which cycle it is contained (-1 if no cycle), is it hybrid, does it has hybrid edges, edges number attached to it  #  PhyloNetworks.readTrees2CF     Function .  readTrees2CF(treefile)\nreadTrees2CF(vector of trees)  Read trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:   quartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.  whichQ=\"rand\": to choose a random sample of 4-taxon subsets  numQ: size of random sample (ignored if whichQ is not set to \"rand\")  writeTab=false: does not write the observedCF to a table (default true)  CFfile: name of file to save the observedCF (default tableCF.txt)  writeQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).   #  PhyloNetworks.readTableCF     Function .  readTableCF(file)\nreadTableCF(data frame)  Read a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named 'CF12_34', 'CF13_24' and 'CF14_23', or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.  Optional arguments:   summaryfile: if specified, a summary file will be created with that name.  sep (for the second form only): to specify the type of separator in the file, with single quotes: sep=';'.   #  PhyloNetworks.readInputTrees     Function .  readInputTrees(file)  function to read a text file with a list of trees in parenthetical format (one tree per line), it returns an array of HybridNetwork object.  #  PhyloNetworks.summarizeDataCF     Function .  summarizeDataCF(d::DataCF)  function to summarize the information contained in a DataCF object. It has the following optional arguments: - filename: if provided, the summary will be saved in the filename, not to screen - pc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold  #  PhyloNetworks.snaq!     Function .  snaq!(T::HybridNetwork, d::DataCF)  Estimate the network (or tree) to fit observed concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. The search starts from topology  T , which can be a tree or a network with no more than  hmax  hybrid nodes. The function name ends with ! because it modifies the CF data  d  by updating its attributes  expCF : CFs expected under the network model. It does  not  modify  T . The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.  There are many optional arguments, including   hmax: maximum number of hybridizations allowed (default 1)  verbose: if true, it prints information about the numerical optimization  runs: number of independent starting points for the search (default 10)  outgroup: outgroup taxon to root the estimated topology at the very end  filename: root name for the output files. Default is \"snaq\". If empty (\"\"),   files are  not  created, progress log goes to the screen only (standard out)   and the best network is returned.  seed: seed to replicate a given search   See also:  topologyMaxQPseudolik!  to optimize parameters on a fixed topology, and  topologyQPseudolik!  to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.  Reference: Claudia Sol\u00eds-Lemus and C\u00e9cile An\u00e9 (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting.  PLoS Genetics  12(3):e1005896  #  PhyloNetworks.readSnaqNetwork     Function .  readSnaqNetwork(output file)  function to read the estimated network from an .out file generated by the snaq function  #  PhyloNetworks.snaqDebug     Function .  snaqDebug(currT::HybridNetwork,d::DataCF)  function to replicate a given run that produces error according to the .err file generated by snaq. The same settings used in that run should be used in this function, specially the seed. See the readme file online for more details.  #  PhyloNetworks.topologyMaxQPseudolik!     Function .  topologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)  Estimate the branch lengths and inheritance probabilities (\u03b3's) for a given network topology. The network is  not  modified, only the object  d  is, with updated expected concordance factors.  Ouput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with  net.loglik .  Optional arguments (default value):   verbose (false): if true, information on the numerical optimization is printed to screen  ftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4):   absolute and relative tolerance values for the pseudo-deviance function   and the parameters   #  PhyloNetworks.topologyQPseudolik!     Function .  topologyQPseudolik!(net::HybridNetwork, d::DataCF)  Calculate the quartet pseudo-deviance of a given network/tree for DataCF  d . This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.  Be careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.  The loglik attribute of the network is undated, and  d  is updated with the expected concordance factors under the input network.  #  PhyloNetworks.rootatnode!     Function .  rootatnode!(HybridNetwork, nodeNumber::Int64; index=false::Bool)  rootatnode!(HybridNetwork, Node)  rootatnode!(HybridNetwork, nodeName::AbstractString)  Roots the network/tree object at the node with name 'nodeName' or number 'nodeNumber' (by default) or with index 'nodeNumber' if index=true. Attributes isChild1 and containRoot are updated along the way. Use  plot(net, showNodeNumber=true, showEdgeLength=false)  to visualize and identify a node of interest.  Returns the network.  Warnings: - If the node is a leaf, the root will be placed along   the edge adjacent to the leaf, with a message. This might add a new node. - If the desired root placement is incompatible with one or more hybrids, then   * a RootMismatch error is thrown   * the input network will still have some attributes modified.  See also:  rootonedge! .  #  PhyloNetworks.rootonedge!     Function .  rootonedge!(HybridNetwork, edgeNumber::Int64; index=false::Bool)  rootonedge!(HybridNetwork, Edge)  Roots the network/tree object along an edge with number 'edgeNumber' (by default) or with index 'edgeNumber if index=true. Attributes isChild1 and containRoot are updated along the way.  This adds a new node and a new edge to the network. Use  plot(net, showEdgeNumber=true, showEdgeLength=false)  to visualize and identify an edge of interest.  See also:  rootatnode! .  #  PhyloNetworks.directEdges!     Function .  directEdges!(net::HybridNetwork; checkMajor=true::Bool)  Updates the edges' attribute  isChild1 , according to the root placement. Also updates edges' attribute  containRoot , for other possible root placements compatible with the direction of existing hybrid edges. Relies on hybrid nodes having exactly 1 major hybrid parent edge, but checks for that if checkMajor=true.  Warning: Assumes that isChild1 is correct on hybrid edges (to avoid changing the identity of which nodes are hybrids and which are not).  Returns the network. Throws a 'RootMismatch' Exception if the root was found to conflict with the direction of any hybrid edge.  #  PhyloNetworks.preorder!     Function .  preorder!(net::HybridNetwork)  Updates attribute net.nodes_changed in which the nodes are pre-ordered (also called topological sorting), such that each node is visited after its parent(s). The edges' direction needs to be correct before calling preorder!, using directEdges!  #  PhyloNetworks.cladewiseorder!     Function .  cladewiseorder!(net::HybridNetwork)  Updates attribute net.cladewiseorder_nodeIndex. Used for plotting the network. In the major tree, all nodes in a given clade are consecutive. On a tree, this function also provides a pre-ordering of the nodes. The edges' direction needs to be correct before calling cladewiseorder!, using directEdges!  #  PhyloNetworks.fittedQuartetCF     Function .  fittedQuartetCF(d::DataCF, format::Symbol)  return a data frame with the observed and expected quartet concordance factors after estimation of a network with snaq(T,d). The format can be :wide (default) or :long.   if wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns   for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.  if long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns:   4 columns for the taxon names, one column to give the quartet resolution, one column for   the observed CF and the last column for the expected CF.   see also:  topologyQPseudolik!  and  topologyMaxQPseudolik!  to update the fitted CF expected under a specific network, inside the DataCF object  d .  #  PhyloNetworks.plotNetGraphViz     Function .  plotNetGraphViz(net::HybridNetwork)  function to plot a HybridNetwork object. The plot will be saved in the working directory as a svg file. We are working on allowing other file formats, and to have the plot pop out in a window. This function has the following optional arguments: - imageName: name for plot file (default netImage) - mainTree: if true, only the underlying tree (with major hybrid edges) is plotted (default false) - width: width of image in inches (default 6) - height: height of image in inches (default 8) - vert: if true, plot displayed from top to bottom (default tre) - internalLabels: if true, prints number for internal nodes (default false) - fontSize: font size for taxon names (default 16.0) - hybridColor: color for hybrid edges (default green4) - unrooted: if true, prints the topology unrooted - nodeSeparation: minimum distance between nodes in inches (default 0.8) - labelAngle: angle for leaf label placement (default 180.0) - labelDistance: distance for leaf label placement (default 3.0) - includeGamma: if true, includes the gamma values in the plot (default false) - includeLength: if true, includes the branch lengths in the plot (default false  #  Gadfly.plot     Function .  plot(net::HybridNetwork; useEdgeLength=false, mainTree=false, showTipLabel=true,\n     showNodeNumber=false, showEdgeLength=false, showGamma=false, edgeColor=colorant black ,\n     majorHybridEdgeColor=colorant deepskyblue4 , minorHybridEdgeColor=colorant deepskyblue ,\n     showEdgeNumber=false, showIntNodeLabel=false, edgeLabel=[], nodeLabel=[])  Plots a network, from left to right.   useEdgeLength: if true, the tree edges and major hybrid edges are   drawn proportionally to their length. Minor hybrid edges are not, however.   Note that edge lengths in coalescent units may scale very poorly with time.  mainTree: if true, the minor hybrid edges are ommitted.  showTipLabel: if true, taxon labels are shown. You may need to zoom out to see them.  showNodeNumbers: if true, nodes are labelled with the number used internally.  showEdgeLength: if true, edges are labelled with their length (above)  showGamma: if true, hybrid edges are labelled with their heritability (below)  edgeColor: color for tree edges. black by default.  majorHybridEdgeColor: color for major hybrid edges  minorHybridEdgeColor: color for minor hybrid edges  showEdgeNumber: if true, edges are labelled with the number used internally.  showIntNodeLabel: if true, internal nodes are labelled with their names.   Useful for hybrid nodes, which do have tags like '#H1'.  edgeLabel: dataframe with two columns: the first with edge numbers, the second with labels   (like bootstrap values) to annotate edges. empty by default.  nodeLabel: dataframe with two columns: the first with node numbers, the second with labels   (like bootstrap values for hybrid relationships) to annotate nodes. empty by default.   Note that plot() actually modifies some (minor) attributes of the network, as it calls directEdges!, preorder! and cladewiseorder!.  If hybrid edges cross tree and major edges, you may choose to rotate some tree edges to eliminate crossing edges, using rotate!.  #  PhyloNetworks.setLength!     Function .  setLength!(Edge,new length)  set a new length for an object Edge. The new length needs to be positive. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their lengths. You can then change the length of the 3rd edge with setLength!(net.edge[3],1.2).  #  PhyloNetworks.setGamma!     Function .  setGamma!(Edge,new gamma)  sets a gamma value for a hybrid edge (it has to be a hybrid edge) and new gamma needs to be (0,1). The function will automatically change the gamma value for the other hybrid edge to 1-gamma. For example, if you have a HybridNetwork object net, and do printEdges(net), you can see the list of Edges and their gammas. You can then change the length of the hybrid edge (assume it is in position 3) with setGamma!(net.edge[3],0.2). This will automatically set the gamma for the other hybrid edge to 0.8.  #  PhyloNetworks.mapAllelesCFtable     Function .  mapAllelesCFtable(mapping file, cf file)  function that change the allele names in the CF table to species names. The new DataFrame object is returned. Optional argument: filename for the resulting CF table. If not specified, then no CF is saved as file.  #  PhyloNetworks.deleteHybridThreshold!     Function .  deleteHybridThreshold!(net::HybridNetwork,gamma::Float64)  Deletes from a network all hybrid edges with heritability below a threshold gamma. Returns the network.   if gamma 0.5: deletes     minor hybrid edges with gamma value    threshold  if gamma=0.5: deletes all minor hybrid edges (i.e gamma value  = threshold)   Warning: assumes correct isMajor attributes.  #  PhyloNetworks.displayedTrees     Function .  displayedTrees(net::HybridNetwork, gamma::Float64)  Warning: assumes correct isMajor attributes.  Extracts all trees displayed in a network, following hybrid edges with heritability  = gamma threshold (or  0.5 if threshold=0.5) and ignoring any hybrid edge with heritability lower than gamma. Returns an array of trees, as HybridNetwork objects.  #  PhyloNetworks.majorTree     Function .  majorTree(net::HybridNetwork)  Warning: assumes correct isMajor attributes.  Extracts the major tree displayed in a network, keeping the major edge and dropping the minor edge at each hybrid node. Returns a HybridNetwork object.  #  PhyloNetworks.minorTreeAt     Function .  minorTreeAt(net::HybridNetwork, hybindex::Int64)  Warning: assumes correct isMajor attributes.  Extracts the tree displayed in the network, following the major hybrid edge at each hybrid node, except at the ith hybrid node (i=hybindex), where the minor hybrid edge is kept instead of the major hybrid edge.  #  PhyloNetworks.displayedNetworkAt!     Function .  displayedNetworkAt!(net::HybridNetwork, node::Node)  Warning: assumes correct isMajor attributes.  Deletes all the minor hybrid edges, except at input node. The network is left with a single hybridization, and otherwise displays the same major tree as before.  #  PhyloNetworks.hardwiredClusters     Function .  hardwiredClusters(net::HybridNetwork, S::Union{Vector{ASCIIString},Vector{Int64}})  Returns a matrix describing all the hardwired clusters in a network. Warnings: Clusters are rooted, so the root must be correct.           Allows for missing taxa, with entries all 0.  Each row corresponds to one internal edge, that is, external edges are excluded. If the root is a leaf node, the external edge to that leaf is included (first row). Both parent hybrid edges to a given hybrid node only contribute a single row (they share the same hardwired cluster).   first column: edge number  next columns: 0/1 values. 1=descendant of edge, 0=not a descendant, or missing taxon.  last column:  10/11 values. 10=tree edge, 11=hybrid edge   #  PhyloNetworks.hardwiredCluster     Function .  hardwiredCluster(edge::Edge,taxa::Union{Vector{ASCIIString},Vector{Int64}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{ASCIIString},Vector{Int64}})\nhardwiredCluster!(v::Vector{Bool},edge::Edge,taxa::Union{Vector{ASCIIString},Vector{Int64}},\n                  visited::Vector{Int64})  Calculate the hardwired cluster of  node , coded a vector of booleans: true for taxa that are descendent of nodes, false for other taxa (including missing taxa).  The node should belong in a rooted network for which isChild1 is up-to-date. Run directEdges! beforehand. This is very important, otherwise one might enter an infinite loop, and the function does not test for this.  visited: vector of node numbers, of all visited nodes.  Examples: #\"  julia  net5 =  (A,((B,#H1),(((C,(E)#H2),(#H2,F)),(D)#H1)));  |  readTopology |  directEdges! ;\n\njulia  taxa = net5 |  tipLabels # ABC EF D\n6-element Array{ASCIIString,1}:\n  A \n  B \n  C \n  E \n  F \n  D \n\njulia  hardwiredCluster(net5.edge[12], taxa) # descendants of 12th edge = CEF\n6-element Array{Bool,1}:\n false\n false\n  true\n  true\n  true\n false  #  PhyloNetworks.hardwiredClusterDistance     Function .  hardwiredClusterDistance(net1::HybridNetwork, net2::HybridNetwork, rooted::Bool)  Takes 2 networks and returns their hardwired cluster distance, that is, the number of hardwired clusters found in one network and not in the other. Note that this is not a distance per se on the full space of hybrid networks: there are pairs of different networks for which this measure is 0. But it is a distance on some network subspaces.  If the 2 networks are trees, this is the Robinson-Foulds distance. If rooted=false, the trees are considered unrooted.  #  PhyloNetworks.treeEdgesBootstrap     Function .  treeEdgesBootstrap(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork)  read a list of bootstrap networks ( boot_net ) and a reference network ( ref_net ), and calculate the bootstrap support of the tree edges in the reference network. All minor hybrid edges (\u03b3 0.5) are removed to extract the major tree from each network. All remaining edges are tree edges, each associated with a bipartition.  output: - a data frame with one row per tree edge and two columns: edge number, bootstrap support   (as a percentage) - the major tree from the reference network, where minor hybrid edges (with \u03b3 0.5)   have been removed.  #  PhyloNetworks.hybridDetection     Function .  hybridDetection(net::Vector{HybridNetwork}, net1::HybridNetwork, outgroup::AbstractString)  function can only compare hybrid nodes in networks that have the same underlying major tree also, need to root all networks in the same place, and the root has to be compatible with the direction of the hybrid edges  it computes the rooted hardwired distance between networks, the root matters. input: vector of bootstrap networks (net), estimated network (net1), outgroup  returns    a matrix with one row per bootstrap network, and 2*number of hybrids in net1, column i corresponds to whether hybrid i (net1.hybrid[i]) is found in the bootstrap network, column 2i+1 corresponds to the estimated gamma on the bootstrap network (0.0 if hybrid not found)    list of discrepant trees (trees not matching the main tree in net1)    #  PhyloNetworks.summarizeHFdf     Function .  summarizeHFdf(HFmat::Matrix)  function to summarize df output from hybridDetection input: HFdf (see hybridDetection) returns dataframe with one row per hybrid, and 5 columns:    hybrid index (order from estimated network, see hybridDetection),    number of bootstrap trees that match the underlying tree of estimated network, - number of bootstrap networks that have the hybrid    mean estimated gamma in the bootstrap networks that have the hybrid    sd estimated gamma in the bootstrap networks that have the hybrid also    last row has index -1, and the third column has the number of networks that have all hybrids (hybrid index, mean gamma, sd gamma are meaningless in this last row)  #  PhyloNetworks.hybridBootstrapSupport     Function .  hybridBootstrapSupport(boot_net::Vector{HybridNetwork}, ref_net::HybridNetwork; rooted=false)  Match hybrid nodes in a reference network with those in an array of networks, like bootstrap networks. All networks must be fully resolved, and on the same taxon set. If  rooted=true , all networks are assumed to have been properly rooted beforehand. Otherwise, the origin of each hybrid edge is considered as an unrooted bipartition (default).  Two hybrid edges in two networks are said to match if they share the same \"hybrid\" clade (or recipient) and the same \"donor clade\", which is a sister to the hybrid clade in the network. Since a hybrid clade has 2 parent edges, it is sister to two clades simultaneously: one is its major sister (following the major hybrid edge with \u03b3 0.5) and one is its minor sister (following the major hybrid edge with \u03b3 0.5).  To calculate these hybrid and sister clades at a given hybrid node, all other hybrid edges are first removed from the network. Then, the hybrid clade is the hardwired cluster (descendants) of either hybrid edge and major/minor clade is the hardwired cluster of the sibling edge of the major/minor hybrid parent. If  rooted=false , sister clades are considered as bipartitions.  Output:    a \"node\" data frame with one row per clade and 9 columns giving:    clade : the clade's name, like the taxon name (if a hybrid is a single taxon) or      the hybrid tag (like 'H1') in the reference network   node : the node number in the reference network. NA if the clade is not in this network.  hybridnode : typically the same node number as above, except for hybrid clades in the      reference network. For those, the hybrid node number is listed here.  edge : number of the parent edge, parent to the node in column 2,      if found in the ref network. NA otherwise.  BS_hybrid : percentage of bootstrap networks in which the clade is found to be a hybrid clade.  BS_sister : percentage of bootstrap networks in which the clade is found to be sister to      some hybrid clade (sum of the next 2 columns)  BS_major_sister : percentage of bootstrap networks in which the clade is found to be the      major sister to some hybrid clade  BS_minor_sister : same as 7, but minor   BS_hybrid_samesisters : percentage of bootstrap networks in which the clade is found to be      a hybrid and with the same set of sister clades as in the reference network.      Applies to hybrid clades found in the reference network only, NA for all other clades.    an \"edge\" data frame with one row for each pair of clades, and 8 columns:    edge : hybrid edge number, if the edge appears in the reference network. NA otherwise.   hybrid_clade : name of the clade found to be a hybrid, descendent of 'edge'  hybrid : node number of that clade, if it appears in the reference network. NA otherwise.  sister_clade : name of the clade that is sister to 'edge', i.e. be sister to a hybrid  sister : node number of that clade, if in the ref network.  BS_hybrid_edge : percentage of bootstrap networks in which 'edge' is found to be a hybrid      edge, i.e. when the clade in the 'hybrid' column is found to be a hybrid and the clade in      the 'sister' column is one of its sisters.  BS_major : percentage of bootstrap networks in which 'edge' is found to be a major hybrid      edge, i.e. when 'hybrid' is found to be a hybrid clade and 'sister' is found to be its      major sister.   BS_minor : same as 7, but minor    a \"clade\" data frame to describe the make up of all clades found as hybrids or sisters,   starting with a column  taxa  that lists all taxa. All other columns correspond to a given   clade and contain true/false values.  true  means that a given taxon belongs in a given clade.   For a clade named  H1 , for instance, and if the data frame was named 'cla', the   list of taxa in this clade can be obtained with  cla[:taxa][cla[:H1]] .    an array of gamma values, with one row for each bootstrap network and two columns (major/minor) for each hybrid   edge in the reference network. If this hybrid edge was found in the bootstrap network   (i.e. same hybrid and sister clades, after removal of all other hybrid nodes),   its bootstrap gamma value is recorded here. Otherwise, the gamma entry is 0.0.    an vector with the number of each hybrid edge in the reference network, in the same order   as for the columns in the array of gamma values above.    #  PhyloNetworks.bootsnaq     Function .  bootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)  Bootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame  df . Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see  readBootstrapTrees  to generate this, from a file containing a list of bootstrap files: one per locus).  From each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology  T . Optional arguments include the following, with default values in parentheses:   hmax (1): max number of reticulations in the estimated networks  nrep (10): number of bootstrap replicates.  runs (10): number of independent optimization runs for each replicate  filename (bootsnaq): root name for output files  seed (0 to get a random seed from the clock): seed for random number generator   #  PhyloNetworks.readBootstrapTrees     Function .  readBootstrapTrees(filename)  input: name of file containing the path/name to multiple bootstrap files, one per line. Each bootstrap file corresponds to bootstrap trees from a single gene.  output: vector of vectors of trees.  #  PhyloNetworks.readMultiTopology     Function .  readMultiTopology(file)  Read a text file with a list of networks in parenthetical format (one per line). Crash if a network is broken over several lines. Return an array of HybridNetwork object.  #  PhyloNetworks.hybridatnode!     Function .  hybridatnode!(net::HybridNetwork, nodeNumber::Int64)  Changes the hybrid in a cycle to the node with number  nodeNumber . This node must be in one (and only one) cycle, otherwise an error will be thrown.  Example #\"  julia  net = readTopology( (A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1; );\njulia  plot(net, showNodeNumber=true)\njulia  hybridatnode!(net, -4)\njulia  plot(net)", 
            "title": "Functions"
        }, 
        {
            "location": "/#index", 
            "text": "PhyloNetworks.DataCF  PhyloNetworks.HybridNetwork  PhyloNetworks.Quartet  Gadfly.plot  PhyloNetworks.bootsnaq  PhyloNetworks.cladewiseorder!  PhyloNetworks.deleteHybridThreshold!  PhyloNetworks.deleteleaf!  PhyloNetworks.directEdges!  PhyloNetworks.displayedNetworkAt!  PhyloNetworks.displayedTrees  PhyloNetworks.fittedQuartetCF  PhyloNetworks.hardwiredCluster  PhyloNetworks.hardwiredClusterDistance  PhyloNetworks.hardwiredClusters  PhyloNetworks.hybridBootstrapSupport  PhyloNetworks.hybridDetection  PhyloNetworks.hybridatnode!  PhyloNetworks.majorTree  PhyloNetworks.mapAllelesCFtable  PhyloNetworks.minorTreeAt  PhyloNetworks.plotNetGraphViz  PhyloNetworks.preorder!  PhyloNetworks.printEdges  PhyloNetworks.printNodes  PhyloNetworks.readBootstrapTrees  PhyloNetworks.readInputTrees  PhyloNetworks.readMultiTopology  PhyloNetworks.readSnaqNetwork  PhyloNetworks.readTableCF  PhyloNetworks.readTopology  PhyloNetworks.readTopologyLevel1  PhyloNetworks.readTrees2CF  PhyloNetworks.rootatnode!  PhyloNetworks.rootonedge!  PhyloNetworks.setGamma!  PhyloNetworks.setLength!  PhyloNetworks.snaq!  PhyloNetworks.snaqDebug  PhyloNetworks.summarizeDataCF  PhyloNetworks.summarizeHFdf  PhyloNetworks.tipLabels  PhyloNetworks.topologyMaxQPseudolik!  PhyloNetworks.topologyQPseudolik!  PhyloNetworks.treeEdgesBootstrap  PhyloNetworks.writeTopology", 
            "title": "Index"
        }
    ]
}